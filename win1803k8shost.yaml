AWSTemplateFormatVersion: 2010-09-09
Parameters:
  InstanceTypeParameter:
    Type: String
    Default: t3.xlarge
    Description: Enter instance size. Default is t3.xlarge.
  AMI:
    Type: String
    Default: ami-0a730289c7c16e141
    Description: AMI Image
  VpcId:
    Description: The VPC of the worker instances
    Type: AWS::EC2::VPC::Id
  Subnets:
    Description: The subnets where workers can be created.
    Type: List<AWS::EC2::Subnet::Id>
  ClusterName:
    Description: The cluster name provided when the cluster was created. If it is incorrect, nodes will not be able to join the cluster.
    Type: String
  ClusterControlPlaneSecurityGroup:
    Description: The security group of the cluster control plane.
    Type: AWS::EC2::SecurityGroup::Id

Resources:
  NodeInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: "/"
      Roles:
      - !Ref NodeInstanceRole

  NodeInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: "/"
      ManagedPolicyArns:
      - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy
      - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy
      - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly

  NodeSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for all nodes in the cluster
      VpcId:
        !Ref VpcId
      Tags:
      - Key: !Sub "kubernetes.io/cluster/${ClusterName}"
        Value: 'owned'

  NodeSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    DependsOn: NodeSecurityGroup
    Properties:
      Description: Allow node to communicate with each other
      GroupId: !Ref NodeSecurityGroup
      SourceSecurityGroupId: !Ref NodeSecurityGroup
      IpProtocol: '-1'
      FromPort: 0
      ToPort: 65535

  NodeSecurityGroupFromControlPlaneIngress:
    Type: AWS::EC2::SecurityGroupIngress
    DependsOn: NodeSecurityGroup
    Properties:
      Description: Allow worker Kubelets and pods to receive communication from the cluster control plane
      GroupId: !Ref NodeSecurityGroup
      SourceSecurityGroupId: !Ref ClusterControlPlaneSecurityGroup
      IpProtocol: tcp
      FromPort: 1025
      ToPort: 65535

  ControlPlaneEgressToNodeSecurityGroup:
    Type: AWS::EC2::SecurityGroupEgress
    DependsOn: NodeSecurityGroup
    Properties:
      Description: Allow the cluster control plane to communicate with worker Kubelet and pods
      GroupId: !Ref ClusterControlPlaneSecurityGroup
      DestinationSecurityGroupId: !Ref NodeSecurityGroup
      IpProtocol: tcp
      FromPort: 1025
      ToPort: 65535

  NodeSecurityGroupFromControlPlaneOn443Ingress:
    Type: AWS::EC2::SecurityGroupIngress
    DependsOn: NodeSecurityGroup
    Properties:
      Description: Allow pods running extension API servers on port 443 to receive communication from cluster control plane
      GroupId: !Ref NodeSecurityGroup
      SourceSecurityGroupId: !Ref ClusterControlPlaneSecurityGroup
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443

  ControlPlaneEgressToNodeSecurityGroupOn443:
    Type: AWS::EC2::SecurityGroupEgress
    DependsOn: NodeSecurityGroup
    Properties:
      Description: Allow the cluster control plane to communicate with pods running extension API servers on port 443
      GroupId: !Ref ClusterControlPlaneSecurityGroup
      DestinationSecurityGroupId: !Ref NodeSecurityGroup
      IpProtocol: tcp
      FromPort: 443
      ToPort: 443

  ClusterControlPlaneSecurityGroupIngress:
    Type: AWS::EC2::SecurityGroupIngress
    DependsOn: NodeSecurityGroup
    Properties:
      Description: Allow pods to communicate with the cluster API Server
      GroupId: !Ref ClusterControlPlaneSecurityGroup
      SourceSecurityGroupId: !Ref NodeSecurityGroup
      IpProtocol: tcp
      ToPort: 443
      FromPort: 443

  NodeAddress:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  AssociateNodePort:
    Type: AWS::EC2::EIPAssociation
    Properties:
      AllocationId: !GetAtt NodeAddress.AllocationId
      NetworkInterfaceId: !Ref Eth0

  Eth0:
    Type: AWS::EC2::NetworkInterface
    Properties:
      Description: eth0
      GroupSet:
      - Ref: NodeSecurityGroup
      SourceDestCheck: 'true'
      SubnetId: !Select [ 0, !Ref Subnets ]
      Tags:
      - Key: Name
        Value: Interface 0
      - Key: Interface
        Value: eth0

  Eth1:
    Type: AWS::EC2::NetworkInterface
    Properties:
      Description: eth1
      SourceDestCheck: 'true'
      SubnetId: !Select [ 0, !Ref Subnets ]
      Tags:
      - Key: Name
        Value: Interface 1
      - Key: Interface
        Value: eth1

  Windows:
    Type: 'AWS::EC2::Instance'
    Properties:
      ImageId: !Ref AMI
      InstanceType:
        Ref: InstanceTypeParameter
      KeyName: DukeLegion
      IamInstanceProfile: !Ref NodeInstanceProfile
      NetworkInterfaces:
      - NetworkInterfaceId: !Ref 'Eth0'
        DeviceIndex: '0'
      - NetworkInterfaceId: !Ref 'Eth1'
        DeviceIndex: '1'
      Tags:
      -
        Key: Appplication
        Value: Windows Server 1803
      -
        Key: Domain
        Value: None
      -
        Key: Environment
        Value: Test
      -
        Key: LifeTime
        Value: Transient
      -
        Key: Name
        Value: Kubernete Windows Server 1803 Node
      -
        Key: OS
        Value: Windows
      -
        Key: OwnerContact
        Value: "#{Deployer Contact}"
      -
        Key: Purpose
        Value: Support Test Instance
      -
        Key: Source
        Value: CloudForation Script in Octopus Deploy
      -
        Key: scheduler:ec2-startstop
        Value: false
      UserData:
        Fn::Base64: !Sub |
          <powershell>
          # Based on https://docs.microsoft.com/en-us/virtualization/windowscontainers/kubernetes/getting-started-kubernetes-windows#preparing-a-windows-node

          # There is a delay until the networking is ready
          while (!$(Test-Connection -ComputerName "google.com" -Quiet)) {
            Start-Sleep 5
          }

          # Install chocolatey
          Set-ExecutionPolicy Bypass -Scope Process -Force
          iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
          # Need a console text editor
          choco install vim -y
          # Need the AWS CLI
          choco install awscli -y

          # Set path vars
          $env:Path += ";C:\k;C:\Program Files\Amazon\AWSCLI\;C:\Program Files (x86)\vim\vim80"
          [Environment]::SetEnvironmentVariable("Path", $env:Path + ";C:\k;C:\Program Files\Amazon\AWSCLI\;C:\Program Files (x86)\vim\vim80", [EnvironmentVariableTarget]::Machine)

          # Set k8s vars
          $env:KUBECONFIG="C:\k\config"
          [Environment]::SetEnvironmentVariable("KUBECONFIG", "C:\k\config", [EnvironmentVariableTarget]::Machine)

          mkdir c:\k

          # Download and extract binaries
          wget https://dl.k8s.io/v1.10.7/kubernetes-node-windows-amd64.tar.gz -o c:\k\kubernetes-node-windows-amd64.tar.gz
          wget https://amazon-eks.s3-us-west-2.amazonaws.com/1.10.3/2018-07-26/bin/windows/amd64/aws-iam-authenticator.exe -o c:\k\aws-iam-authenticator.exe
          tar -xzf c:\k\kubernetes-node-windows-amd64.tar.gz -C c:\k
          mv c:\k\kubernetes\node\bin\*.exe c:\k
          cd c:\k
          rm -recurse -force c:\k\kubernetes

          # Get the cluster details
          $clusterEndpoint = & "C:\Program Files\Amazon\AWSCLI\aws" eks describe-cluster --name ${ClusterName} --query cluster.endpoint --output text
          $clusterCa = & "C:\Program Files\Amazon\AWSCLI\aws" eks describe-cluster --name ${ClusterName} --query cluster.certificateAuthority.data --output text

          # Build the kubectl config file
          Set-Content -Path c:\k\config -Value @"
          apiVersion: v1
          clusters:
          - cluster:
              server: $clusterEndpoint
              certificate-authority-data: $clusterCa
            name: kubernetes
          contexts:
          - context:
              cluster: kubernetes
              user: aws
            name: aws
          current-context: aws
          kind: Config
          preferences: {}
          users:
          - name: aws
            user:
              exec:
                apiVersion: client.authentication.k8s.io/v1alpha1
                command: aws-iam-authenticator
                args:
                - "token"
                - "-i"
                - "${ClusterName}"
          "@

          Set-Content -Path Dockerfile -Value @"
          FROM microsoft/nanoserver:1803
          CMD cmd /c ping -t localhost
          "@

          # Build the pause image
          docker pull microsoft/windowsservercore:1803
          docker tag microsoft/windowsservercore:1803 microsoft/windowsservercore:latest
          cd C:/k/
          docker build -t kubeletwin/pause .

          # Get the second nic details
          $ifIndex = Get-NetAdapter -Name "*" |
            ? {$_.Name -like "Ethernet *"} |
            Sort-Object -Property ifIndex -Descending |
            Select-Object -First 1 -ExpandProperty ifIndex

          $gateway = Get-NetIPConfiguration |
            ? {$_.InterfaceIndex -eq $ifIndex} |
            Select-Object -ExpandProperty IPv4DefaultGateway |
            Select-Object -ExpandProperty NextHop

          # Delete the EC2 Metadata route to the first nic (which will
          # not work after we start adding docker networks
          route delete -p 169.254.169.254

          # Direct traffic to the Metadata service via the second nic
          route -p add 169.254.169.254 mask 255.255.255.255 $gateway IF $ifIndex

          # Create the network called "host"
          docker network create -d nat host

          # Turn off Firewall to enable pods to talk to service endpoints. (Kubelet should eventually do this)
          # Is this needed? We don't want to expose Octopus server to each other anyway.
          # https://github.com/andyzhangx/Demo/blob/master/acs-engine/deployment/windows/kubeletstart.ps1
          # netsh advfirewall set allprofiles state off

          # The command to start kubelet
          $KubeDnsServiceIp="11.0.0.10"
          $Hostname = $(& curl -UseBasicParsing http://169.254.169.254/latest/meta-data/local-hostname).Content
          $KubeletCommand = @"
            c:\k\kubelet.exe --hostname-override=$Hostname --v=6 `
              --pod-infra-container-image=kubeletwin/pause --resolv-conf="" `
              --allow-privileged=true --enable-debugging-handlers `
              --cluster-dns=$KubeDnsServiceIp --cluster-domain=cluster.local `
              --kubeconfig=c:\k\config --hairpin-mode=promiscuous-bridge `
              --image-pull-progress-deadline=20m --cgroups-per-qos=false `
              --log-dir=c:\k --logtostderr=false --enforce-node-allocatable="" `
              --network-plugin=cni --cni-bin-dir="c:\k\cni" --cni-conf-dir "c:\k\cni\config" `
              --register-with-taints="os=windows:NoSchedule"
          "@

          # Manage kubelet as a Windows service
          New-Service `
            -Name "kubelet" `
            -BinaryPathName $KubeletCommand `
            -DisplayName "kubelet" `
            -StartupType Manual `
            -Description "Kubernetes kubelet service"
          </powershell>
Outputs:
  PublicIp:
    Value:
      Fn::GetAtt:
      - Windows
      - PublicIp
    Description: Server's PublicIp Address